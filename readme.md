# BinDiffSynchronizer — pjson_db: персистная JSON-база данных

C++17 header-only библиотека для работы с JSON в персистном адресном пространстве (ПАП).

---

## Концепция

**pjson_db** позволяет работать с JSON-данными так же, как с `nlohmann::json`, но с одним принципиальным отличием: все объекты хранятся в **персистном адресном пространстве** — двоичном образе файла, отображённом в память. Это превращает JSON в полноценную базу данных: данные переживают перезапуск программы без сериализации и десериализации.

Помимо стандартного JSON, библиотека поддерживает расширенные типы узлов:

- **`$ref`** — настоящий указатель на другой узел (не текстовый путь, а прямая ссылка в ПАП)
- **`$base64`** — бинарные данные (хранятся как байтовый массив, сериализуются в base64)

---

## Ключевые характеристики

| Характеристика | Описание |
|---|---|
| **Header-only** | Вся реализация — только `.h` файлы, без `.cpp` |
| **C++17** | Без внешних зависимостей |
| **Персистность** | Данные в ПАП переживают перезапуск без явной сериализации |
| **Интернирование строк** | Все строки хранятся в едином словаре ПАП, дедуплицированы, сравнение O(1) |
| **Нет SSO в строках** | Все строки, включая короткие, хранятся в ПАП (необходимо для сквозного поиска) |
| **Path-адресация** | Доступ к узлам через строковые пути вида `/a/b/0/c` |
| **$ref как указатели** | `{ "$ref": "/path" }` при разборе становится прямым указателем в ПАП |
| **Метрики** | Статистика БД доступна через `/$metrics/...` |
| **Поиск по строкам** | Сквозной поиск по всем строкам словаря ПАП |

---

## Расширения JSON

### `$ref` — ссылки (указатели)

```json
{
  "config": { "$ref": "/defaults/config" }
}
```

При разборе объект `{ "$ref": "path" }` (ровно один ключ) преобразуется в **ref-узел** в ПАП:

- `ref_val.path` — интернированный путь (для сериализации и диагностики)
- `ref_val.target` — прямой `node_id` целевого узла (разрешается при загрузке)

При чтении через `get()` ref-узлы разыменовываются автоматически. Обнаруживаются циклические ссылки (ошибка `ref_cycle`).

### `$base64` — бинарные данные

```json
{
  "thumbnail": { "$base64": "iVBORw0KGgoAAAANSUhEUgAA..." }
}
```

При разборе объект `{ "$base64": "..." }` преобразуется в **binary-узел** с байтовым массивом в ПАП. При сериализации байтовый массив кодируется обратно в base64.

---

## Архитектура

### Слои системы

```
┌─────────────────────────────────────────────┐
│   Слой D: pjson_db                          │
│   (path-адресация, $ref, метрики, API)      │
├─────────────────────────────────────────────┤
│   Слой C: pjson_node + pjson_pool           │
│   (модель узлов, пул аллокации)             │
├─────────────────────────────────────────────┤
│   Слой C: pjson_codec                       │
│   (парсинг, сериализация, base64)           │
├─────────────────────────────────────────────┤
│   Слой B: pstringview + pmem_array          │
│   (словарь строк, общий примитив массивов)  │
├─────────────────────────────────────────────┤
│   Слой A: pam_core + pam                    │
│   (ПАП: аллокатор, слоты, realloc)         │
└─────────────────────────────────────────────┘
```

### Файлы проекта

| Файл | Слой | Описание |
|------|------|----------|
| `pam_core.h` | A | Ядро ПАМ: аллокатор, слоты, карта имён, realloc |
| `pam.h` | A | Фасад: включает pvector, pmap, pstring |
| `persist.h` | A | Базовые типы: fptr<T>, persist<T>, AddressManager |
| `pvector.h` | B | Персистный динамический массив |
| `pmap.h` | B | Персистная карта (sorted array) |
| `pstring.h` | B | Персистная строка (внутренняя утилита) |
| `pstringview.h` | B | Интернированная read-only строка + словарь ПАП |
| `pallocator.h` | B | STL-совместимый аллокатор поверх ПАМ |
| `pjson.h` | C | Персистный JSON: узлы, типы, layout |
| `pjson_interning.h` | B | Интернирование строк для pjson |
| `pjson_node_pool.h` | C | Пул узлов для быстрой аллокации |
| `pjson_serializer.h` | C | Сериализация/десериализация pjson |
| `main.cpp` | — | Демонстрационная программа |
| `tests/` | — | Тесты на Catch2 |
| `CMakeLists.txt` | — | Система сборки (CMake 3.16+, C++17) |

---

## Типы узлов

```cpp
enum class node_tag : uint32_t {
    null,       // null
    boolean,    // true / false
    integer,    // int64_t
    uinteger,   // uint64_t
    real,       // double
    string,     // интернированная pstringview
    binary,     // pvector<uint8_t> в ПАП ($base64 при сериализации)
    array,      // pvector<node_id>
    object,     // pmap<pstringview, node_id>
    ref,        // pstringview path + node_id target ($ref при сериализации)
};
```

---

## API (целевой интерфейс)

### Открытие базы данных

```cpp
#include "pjson_db.h"

// Открыть или создать базу данных
auto db = pjson_db::open("data.pam");
```

### Запись данных

```cpp
db.put("/users/alice/name",  "Alice");
db.put("/users/alice/age",   30);
db.put("/users/alice/active", true);

db.save(); // сохранить образ ПАП в файл
```

### Чтение данных

```cpp
node_view name = db.get("/users/alice/name");
// name.as_string() -> "Alice"

node_view age = db.get("/users/alice/age");
// age.as_int() -> 30
```

### Работа с `$ref`

```cpp
// Создать ссылку (парсинг JSON)
db.parse(R"({"link": {"$ref": "/users/alice"}})");

// Чтение автоматически разыменовывает ссылки
node_view linked_user = db.get("/link"); // → узел /users/alice

// Явное разыменование без следования по ссылке
node_view ref_node = db.get("/link", /*deref_ref=*/false);
```

### Работа с `$base64`

```cpp
// Парсинг бинарных данных
db.parse(R"({"data": {"$base64": "AAEC"}})");

// Получение бинарного узла
node_view bin = db.get("/data");
// bin.tag() == node_tag::binary
// bin.binary_size() == 3, данные: [0x00, 0x01, 0x02]

// Сериализация обратно в JSON с $base64
std::string json = db.dump("/data");
// json == {"$base64":"AAEC"}
```

### Метрики

```cpp
// Метрики доступны через зарезервированное пространство /$metrics
node_view node_count = db.get("/$metrics/node_count_total");
node_view str_count  = db.get("/$metrics/string_count_total");

// Попытка записи в метрики — ошибка readonly
db.put("/$metrics/node_count_total", 0); // ошибка!
```

### Поиск по строкам

```cpp
// Найти все строки, содержащие подстроку
auto results = db.search_strings("alice");

// Перебрать весь словарь строк
for (auto sv : db.all_strings()) {
    // sv — pstringview
}
```

---

## Интернирование строк

Все строки в ПАП хранятся в **едином внутреннем словаре** (`pstringview_table`):

- Строки **никогда не удаляются** из словаря (только накапливаются).
- Одинаковые строки → один и тот же `chars_offset`.
- Сравнение строк: **O(1)** через сравнение `chars_offset`.
- **Нет SSO (Small String Optimization)**: даже однобуквенные строки хранятся в ПАП, что обеспечивает **сквозной поиск** по всем строкам.

Благодаря интернированию:
- Ключи объектов хранятся без дублирования.
- Сравнение ключей при поиске — O(1), не O(n).
- Полнотекстовый поиск по всем строковым данным БД.

---

## Персистентность и управление памятью

### Структура файла ПАМ

```
[pam_header]          — заголовок (magic, version, offsets, bump)
[данные ПАП]
  [type_vec]          — вектор типов TypeInfo
  [slot_map]          — карта слотов
  [name_map]          — карта имён объектов
  [free_list]         — список свободных областей (reuse)
  [string_table]      — словарь интернированных строк
  [node_pool]         — пул узлов JSON
  [пользовательские данные]
```

### Управление памятью

- **Bump-allocator**: новые объекты выделяются линейно в конце ПАП.
- **Free-list**: удалённые блоки возвращаются в список свободных, повторно используются (first-fit).
- **Realloc**: `pvector::grow` / `pmap::grow` расширяют последний блок ПАП без копирования.
- **Строки накапливаются**: словарь строк только растёт, строки не освобождаются.

### Правила владения узлами

- Дерево **владеет** своими поддеревьями.
- `ref`-узел **не владеет** целевым узлом.
- При `erase` удаляется только ref-узел; цель не затрагивается.
- Shared-узлы допускаются **только** через `$ref`.

---

## Оптимизация производительности

### Предварительное резервирование

Перед массовой загрузкой данных используйте `ReserveSlots(n)`:

```cpp
db.pam().ReserveSlots(100000); // зарезервировать для 100k узлов
db.parse_file("large_dataset.json");
```

Это устраняет многократные реаллокации и значительно ускоряет парсинг больших JSON-файлов.

### Сброс состояния

```cpp
db.pam().Reset(); // очистить всё ПАП за O(1)
```

Быстрее, чем удаление 100k+ узлов по одному (O(n²)).

---

## Требования

| Требование | Описание |
|---|---|
| Тр.1 | Персистные объекты используют только персистные указатели (смещения) |
| Тр.2 | Создание/удаление объектов — через методы аллокатора ПАМ |
| Тр.3 | При запуске аллокатор инициализируется именем файла-хранилища |
| Тр.4 | Единое ПАП для объектов всех типов |
| Тр.5 | `sizeof(fptr<T>) == sizeof(void*)` |
| Тр.6 | Все комментарии в коде — на русском языке |
| Тр.7 | Никакой логики с именами файлов в `persist<T>` |
| Тр.8 | `sizeof(persist<T>) == sizeof(T)` |
| Тр.9 | Никакой логики с именами файлов в `fptr<T>` |
| Тр.10 | При загрузке образа ПАП конструкторы/деструкторы не вызываются |
| Тр.11 | Объекты `persist<T>` живут только в образе ПАП |
| Тр.12 | Доступ к персистным объектам — только через `fptr<T>` или `node_id` |
| Тр.13 | `fptr<T>` может находиться как в обычной памяти, так и в ПАП |
| Тр.14 | ПАМ — персистный объект, хранит имена объектов и словарь строк |
| Тр.15 | `fptr<T>` инициализируется строковым именем объекта через ПАМ |
| Тр.16 | ПАМ хранит карту объектов, их имена и словарь интернированных строк |
| Тр.17 | Строки в ПАП не имеют SSO — все хранятся через `chars_offset` в словаре |
| Тр.18 | `pjson_db.h` — единственный заголовок для конечного пользователя |

---

## Сборка и тестирование

```bash
cmake -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build
ctest --test-dir build --output-on-failure
```

---

## Лицензия

Unlicense — общественное достояние. Подробности в файле `LICENSE`.
