# План развития проекта BinDiffSynchronizer

## Введение

Данный документ описывает перспективные направления развития проекта BinDiffSynchronizer с точки зрения пользы для человечества. Особое место занимает концепция **jgit** — темпоральной базы данных для JSON-документов, сочетающей модель версионирования Git с нативной поддержкой JSON-структур.

---

## Направление 1: jgit — темпоральная JSON база данных

### Обоснование

Концепция **jgit** — это новаторская идея, объединяющая:
- **Темпоральное хранение**: полная история изменений каждого JSON-документа
- **Git-модель**: ветки, теги, коммиты, слияния для JSON
- **Бинарное хранение**: эффективное хранение в виде множества бинарных файлов
- **`$ref`-ссылки**: перекрёстные ссылки между JSON-репозиториями (аналог git submodules)

Данное направление является наиболее перспективным, так как:
1. Решает реальную проблему — нет open-source Git-подобной системы для JSON
2. Прямо использует существующий механизм `BinDiffSynchronizer` для вычисления дельт
3. Интегрируется с готовой библиотекой [nlohmann/json](https://github.com/nlohmann/json), которая уже предоставляет JSON Pointer, JSON Patch и бинарные форматы

### Архитектура jgit

```
jgit-репозиторий/
├── HEAD                    # Текущая ветка (аналог Git)
├── refs/
│   ├── heads/              # Ветки
│   │   ├── main            # Указатель на последний коммит ветки main
│   │   └── feature-X       # Указатель на последний коммит ветки feature-X
│   └── tags/               # Теги (неизменяемые метки)
│       └── v1.0.0
├── objects/                # Объектное хранилище (content-addressed)
│   ├── ab/                 # Первые 2 символа хеша
│   │   └── cd1234...       # Остаток хеша — бинарный объект (CBOR/MessagePack)
│   └── ...
└── index                   # Текущее состояние рабочего дерева
```

#### Типы объектов jgit

| Тип объекта | Описание | Аналог в Git |
|-------------|----------|--------------|
| `json-blob` | Бинарное представление JSON-узла или поддерева | blob |
| `json-tree` | Список дочерних узлов с их хешами | tree |
| `json-commit` | Метаданные: автор, время, родительский коммит, корневой json-tree | commit |
| `json-patch`  | JSON Patch (RFC 6902) — дельта изменений между версиями | - |
| `json-ref`    | Персистентная ссылка `$ref` на объект в другом репозитории | submodule |

### Задачи по приоритетам

#### Высокий приоритет

1. **Прототип объектного хранилища**
   - Реализовать content-addressed storage на базе `PageDevice`
   - Хеш-функция содержимого для идентификации объектов (SHA-256)
   - Хранение объектов в бинарном формате (CBOR через nlohmann/json)
   - Базовые операции: `put(json)` → hash, `get(hash)` → json

2. **Интеграция с nlohmann/json**
   - Добавить nlohmann/json как header-only зависимость
   - Реализовать сериализацию JSON → CBOR (`nlohmann::json::to_cbor()`)
   - Реализовать сериализацию JSON → MessagePack (`nlohmann::json::to_msgpack()`)
   - Оценить и выбрать оптимальный бинарный формат для jgit

3. **Вычисление JSON-дельт на базе BinDiffSynchronizer**
   - Расширить `BinDiffSynchronizer` для работы с JSON-узлами через nlohmann/json
   - Генерация JSON Patch (RFC 6902) при изменении JSON-объекта
   - Хранение дельт как `json-patch` объектов в объектном хранилище

4. **Система коммитов**
   - Структура `json-commit`: `{hash, parent_hash, author, timestamp, message, root_tree_hash}`
   - Команда `commit(json, message)` — сохранение новой версии документа
   - Команда `checkout(hash)` — восстановление произвольной версии

#### Средний приоритет

5. **Ветки и теги**
   - Реализовать структуру `refs/heads/` для хранения веток
   - Команды: `branch create`, `branch switch`, `branch list`
   - Команды: `tag create`, `tag list`

6. **Слияние (merge)**
   - Реализовать трёхстороннее слияние JSON-документов
   - Использование JSON Merge Patch (RFC 7396) для auto-merge
   - Обнаружение и представление конфликтов слияния

7. **`$ref`-ссылки между репозиториями**
   - Поддержка JSON Schema `$ref` как персистентных ссылок (`fptr<T>`)
   - Разрешение ссылок между различными jgit-репозиториями
   - Транзитивный обход ссылок при операциях чтения/записи

#### Низкий приоритет

8. **Гранулярное версионирование узлов**
   - Версионирование на уровне отдельных JSON Pointer путей
   - История изменений конкретного поля: `log("/user/name")`
   - Blame-like операция: кто и когда изменил конкретный узел

9. **Репликация и синхронизация**
   - Протокол обмена дельтами между jgit-репозиториями
   - Push/pull операции через сетевой транспорт (Protocol из BinDiffSynchronizer)
   - Eventual consistency при репликации

10. **CLI-интерфейс jgit**
    - Командная строка, аналогичная git: `jgit init`, `jgit commit`, `jgit log`, `jgit diff`
    - Поддержка JSON Pointer в командах: `jgit log /user/address`

---

## Направление 2: Модернизация кодовой базы

### Обоснование

Модернизация кода является необходимым фундаментом для реализации jgit и привлечения контрибьюторов.

### Задачи по приоритетам

#### Высокий приоритет

1. **Исправление существующих багов**
   - Исправить `>` на `>>` в `MemoryDevice::Read/Write` (`PageDevice.h:117,131`)
   - Исправить `unsigned addr = NULL` на `unsigned addr = 0` в `AddressManager::Create`
   - Добавить возврат из `fptr<_T>::operator=` (отсутствует `return *this`)
   - Проверить корректность `persist(const _T& ref)` — инициализация через placement new отсутствует

2. **Переход на современный C++17**
   - Заменить `<strstream>` на `<sstream>`
   - Заменить `__forceinline` на `inline` или `[[likely]]`
   - Заменить `typeof` на `decltype`
   - Заменить `_ultoa` на `std::to_string` + `std::hex`
   - Заменить сырые указатели на smart pointers там, где уместно

3. **Кросс-платформенность**
   - Создание `CMakeLists.txt` с поддержкой GCC, Clang, MSVC
   - Замена Windows-специфичных путей (`".\"`) на `std::filesystem`
   - Поддержка Linux и macOS

4. **Безопасность**
   - Заменить `strcpy`/`strcat` на `std::string` или `strncpy`/`strncat`
   - Добавить проверки границ массивов в `AddressManager`
   - Добавить обработку ошибок при работе с файлами

#### Средний приоритет

5. **Тестирование**
   - Восстановить и исправить тестовые функции `test1`/`test2`/`test3` из `main.cpp`
   - Добавить unit-тесты с использованием Catch2 или Google Test
   - Написать тест для каждого исправленного бага

6. **CI/CD**
   - Настроить GitHub Actions для сборки на Linux (GCC, Clang) и Windows (MSVC)
   - Автоматический запуск тестов при push
   - Статический анализ кода (clang-tidy, cppcheck)

#### Низкий приоритет

7. **Рефакторинг качества кода**
   - Добавить `namespace bindiff` для предотвращения конфликтов имён
   - Унифицировать язык комментариев
   - Удалить закомментированный код (или задокументировать причину)
   - Увеличить `ADDRESS_SPACE` или сделать его динамическим

---

## Направление 3: Энергоэффективная синхронизация данных

### Обоснование

В эпоху растущего потребления энергии дата-центрами технология BinDiffSynchronizer, которая передаёт только изменившиеся байты вместо полных объектов, может значительно сократить сетевой трафик и энергопотребление. Особенно актуально для IoT-устройств и облачных сервисов.

### Задачи по приоритетам

#### Высокий приоритет

1. **Завершение ядра синхронизации**
   - Объявить интерфейс `ISyncServer` с методом `SendObjChange`
   - Реализовать накопитель дельт в `BinDiffSynchronizer`
   - Создать протокол передачи дельт (формат пакета: адрес + смещение + данные)

2. **Оптимизация алгоритма сравнения**
   - Реализовать блочное сравнение вместо побайтового (использовать SIMD если доступно)
   - Добавить поддержку контрольных сумм для быстрой проверки изменений
   - Адаптивный порог: если изменено более 50% — передать полный объект

#### Средний приоритет

3. **Сетевой транспорт**
   - Реализовать TCP транспорт с использованием asio (header-only)
   - Добавить поддержку WebSocket для веб-приложений
   - Механизм автоматического переподключения

4. **Сжатие дельт**
   - Интегрировать LZ4 или zstd для сжатия передаваемых дельт
   - Адаптивный выбор: не сжимать маленькие дельты

---

## Направление 4: Надёжное персистентное хранение

### Обоснование

Надёжное хранение данных критически важно для медицинских систем, финансовых транзакций и научных исследований.

### Задачи по приоритетам

#### Высокий приоритет

1. **Журналирование (Write-Ahead Log)**
   - Реализовать WAL для атомарности операций `PageDevice`
   - Добавить точки восстановления (checkpoints)
   - Механизм отката незафиксированных изменений

2. **Целостность данных**
   - Добавить CRC32 контрольные суммы для каждой страницы `PageDevice`
   - Верификация при загрузке страницы
   - Автоматическое восстановление из резервной копии при повреждении

#### Средний приоритет

3. **Инкрементальное резервное копирование**
   - Снимки состояния (snapshots) на базе `dirty` флагов `Cache`
   - Репликация на несколько устройств хранения

4. **Шифрование хранилища**
   - Прозрачное шифрование страниц (AES-256-GCM)
   - Ключ может быть получен из пароля (PBKDF2)

---

## Направление 5: Образовательная платформа

### Обоснование

Проект может служить образовательным инструментом для изучения принципов работы СУБД, системного программирования и алгоритмов синхронизации.

### Задачи по приоритетам

#### Высокий приоритет

1. **Документация API**
   - Создать подробную техническую документацию по каждому компоненту
   - Схема архитектуры с диаграммами зависимостей компонентов

2. **Учебные примеры**
   - Пример 1: базовое использование `persist<T>` и `fptr<T>`
   - Пример 2: использование `BinDiffSynchronizer` для отслеживания изменений объекта
   - Пример 3: прототип простейшего jgit-репозитория

#### Средний приоритет

3. **Визуализация работы кэша**
   - ASCII-арт анимация замещения страниц в `Cache`
   - Статистика hit/miss для оценки эффективности кэширования

---

## Приоритизация направлений

| Направление | Польза для человечества | Сложность | Рекомендуемый порядок |
|-------------|------------------------|-----------|----------------------|
| 1. jgit — JSON темпоральная БД | Уникальная инфраструктура будущего | Очень высокая | 1 |
| 2. Модернизация кодовой базы | Фундамент для всего | Средняя | 2 |
| 3. Энергоэффективная синхронизация | Экология, IoT, экономия | Средняя | 3 |
| 4. Надёжное хранение | Сохранность данных | Высокая | 4 |
| 5. Образование | Развитие специалистов | Низкая | 5 |

---

## Краткосрочный план (1-3 месяца)

1. **Исправить существующие баги** (направление 2, высокий приоритет)
2. **Перевести проект на C++17 с CMake** (направление 2, высокий приоритет)
3. **Добавить nlohmann/json** и написать прототип сериализации JSON→CBOR
4. **Реализовать объектное хранилище** (content-addressed store) — сердце jgit
5. **Написать базовые unit-тесты** для существующего и нового кода

## Среднесрочный план (3-6 месяцев)

1. **Завершить персистную инфраструктуру** (Фаза 3): доработать, задокументировать и протестировать `persist<T>`, `fptr<T>`, `AddressManager<T>`, `Cache`, `Page`, `PageDevice`, `MemoryDevice`, `StaticPageDevice`
2. **Переписать jgit-классы на `persist<T>`/`fptr<T>`**: `persistent_string`, `persistent_map`, `persistent_json_value`, `PersistentJsonStore` — с тестами для каждой инстанции
3. **Инстанцировать `basic_json<>`** на персистных классах; написать тесты для `persist<json>` и `fptr<json>`
4. **Реализовать систему коммитов и веток** jgit (Фаза 4, после завершения Фазы 3)
5. **Интегрировать JSON Patch** (RFC 6902) как формат дельт на базе BinDiffSynchronizer
6. **Поддержка `$ref`-ссылок** через `fptr<T>`
7. **Создать CLI jgit** с командами init, commit, log, diff, checkout
8. **Опубликовать статью** или документацию о концепции jgit

## Долгосрочный план (6-12 месяцев)

1. **Реализовать merge** с разрешением конфликтов (JSON Merge Patch RFC 7396)
2. **Добавить репликацию** через сетевой транспорт (Protocol + BinDiffSynchronizer)
3. **Реализовать WAL** и шифрование хранилища
4. **Создать Python/Rust биндинги** для jgit
5. **Провести сравнительный benchmark** jgit vs CouchDB vs TerminusDB
6. **Опубликовать jgit как отдельный open-source проект**
7. **Реализовать jdb** (Фаза 5) — мультидокументную JSON базу данных на основе jgit
8. **Реализовать jhub** (Фаза 6) — унифицированную платформу разработки на JSON-инфраструктуре

## Направление 6: jhub — JSON-платформа разработки ПО

### Обоснование

Концепция **jhub** формулируется в [issue #36](https://github.com/netkeep80/BinDiffSynchronizer/issues/36): создать платформу разработки следующего поколения, которая унифицирует Git, Docker, CI/CD и Docker Hub в единой JSON-инфраструктуре (jgit + jdb + jsonRVM).

Подробная архитектура и требования описаны в [jhub-tz.md](jhub-tz.md).

### Ключевые компоненты jhub

| Компонент | Описание | Аналог |
|-----------|----------|--------|
| jgit | Темпоральная JSON БД с историей версий | Git |
| jdb | Мультидокументная JSON БД на основе jgit | GitLab database |
| jhub API | REST API сервер для управления всеми компонентами | GitHub/GitLab API |
| jhub Runner | Агент выполнения JSON-пайплайнов (jsonRVM) | GitLab Runner |
| jhub Registry | Реестр Docker образов с метаданными в jdb | Docker Hub |
| jhub Swarm | Управление развёртыванием через Docker Swarm | Docker Swarm/K8s |
| jhub GUI | Web-интерфейс как JSON-приложение на jsonRVM | GitHub/GitLab UI |

---

## Ресурсы и ссылки

- [nlohmann/json](https://github.com/nlohmann/json) — JSON for Modern C++: JSON Pointer, JSON Patch, бинарные форматы
- [jsonRVM](https://github.com/netkeep80/jsonRVM) — движок исполнения JSON-программ (используется в jhub)
- [RFC 6902: JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) — стандарт описания изменений JSON
- [RFC 6901: JSON Pointer](https://datatracker.ietf.org/doc/html/rfc6901) — стандарт адресации узлов JSON
- [RFC 7396: JSON Merge Patch](https://datatracker.ietf.org/doc/html/rfc7396) — стандарт слияния JSON
- [Git Internals](https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain) — архитектура Git как референс для jgit
- [CBOR (RFC 7049)](https://cbor.io/) — бинарный формат для хранения JSON в jgit
- [Docker Registry API v2](https://distribution.github.io/distribution/spec/api/) — API реестра Docker для jhub
- [Docker Swarm](https://docs.docker.com/engine/swarm/) — оркестрация контейнеров для jhub
- [Анализ проекта](analysis.md) — детальный анализ текущего состояния
- [ТЗ jhub](jhub-tz.md) — Техническое задание на разработку jhub

---

*Документ создан: 2026-01-28. Обновлён: 2026-02-26 (добавлено направление 6: jhub, согласно issue #36)*
